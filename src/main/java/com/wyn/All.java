package com.wyn;

/**
 * @ClassName All
 * @Description 仅用作叙述设计模式
 * @Author WENYANNI
 * @Date 2021/10/30 上午10:42
 **/
public class All {
    /**
     * 单例模式：(singleton)
     * 单例模式保证一个类仅有一个实例，并提供一个访问它的全局访问点
     **/

    /**
     * 工厂模式：(factory)
     * 简单工厂、工厂、抽象工厂
     * 当用户需要 一个类的子类实例，且不希望与该类的子类形成耦合或者不知道该类有哪些子类可用时，可采用工厂模式
     * 当用户需要提供多个对象，且希望和创建对象的类解耦时，可采用抽象工厂模式
     **/

    /**
     * 生成器模式/建造者模式：(generate)
     * 将一个复杂对象的构建与它的表示 分离，使同样的构建过程可以创建不同的表示
     * 解决同流程异页面问题的重要手段
     **/

    /**
     * 原型模式：(prototype)
     * 用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
     * 适用场景：
     * 1.从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象
     * 2.对象创建需要独立于它的构造方法和表示
     * 3.以原型对象为基础，克隆新的对象，并完善对象实例变量
     **/

    /**
     * 责任链模式：(responsibility)
     * 使多个对象都有机会处理请求，避免请求的发送者和接收者的耦合关系。
     * 将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它
     * 适用场景：
     * 1.有许多对象可以处理用户的请求，应用程序可自动确定谁可以处理用户请求
     * 2.希望用户不必明确指定接受者的情况下，向多个接受者发起请求
     * 3.希望动态定制可处理用户请求的对象集合
     **/

    /**
     * 命令模式：(command)
     * 将一个请求封装成一个对象，从而使用户可用不同的请求对客户进行参数化
     * 对请求排队或记录请求日志，以及支持可撤销的操作
     *
     * 适用场景：
     * 1.程序需要在不同的时刻指定、排列和执行请求
     * 2.程序需要提供撤销操作
     * 3.程序需要支持宏操作
     *
     * ICommand:抽象命令者，接口，规定了用来封装请求的若干个方法
     * ConcreteCommander:具体命令发送者，实现命令接口的类的实例
     * Invoker:请求者，具体命令的管理与维护类，一个包含命令接口变量的类的实例
     * Receiver:命令接收者，负责执行与请求有关的操作
     *
     **/

    /**
     * 迭代器模式：(iterator)
     * 提供一种方法访问同一个容器对象中的各个元素，而又勿需暴露该对象的内部细节
     *
     * 适用场景：
     * 1.遍历集合对象，不需要知道对象在集合中的存储方式
     * 2.用户可以同时使用多个迭代器遍历一个集合
     **/

    /**
     * 访问者模式：(visitor)
     * 表示一个作用域某对象结构中的各个元素的操作
     * 在不改变各个元素的类的前提下，定义作用于这些元素的新操作
     *
     * 适用场景：
     * 1.对集合中的对象增加一些新的操作
     * 2.对集合中的对象进行很多不同且不相关的操作
     **/

    /**
     * 中介者模式：(intermediary)
     * 指用一个中介对象来封装一些列的对象交互，
     * 中介者使得各对象不需要显式地相互引用，
     * 从而使其耦合松散，而且可以独立地改变它们之间的交互
     **/

    /**
     * 备忘录模式：(memento)
     * 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态
     * 以后可以将该对象恢复到原先保存的状态
     *
     * 适用场景：
     * 1.必须保存某对象在某一时刻的部分或全部状态信息，以便对象恢复到该时刻的运行状态
     * 2.一个对象不想通过提供public权限的方法让其他对象得到自己的内部状态
     **/

    /**
     * 观察者模式：(observer)
     * 定义对象的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖他的的对象都得到通知并被自动更新
     *
     * 适用场景：
     * 1.当某对象数据更新时需要通知其他对象，但该对象又不希望和被通知的其他对象形成紧耦合
     * 2.当其对象数据更新时，需要让其他对象也各自更新自己的数据，但该对象不知道具体有多少对象需要更新数据
     **/

    /**
     * 状态模式：(status)
     * 允许一个对象在其内部状态改变时改变他的行为，使对象看起来似乎修改了它的类
     *
     * 适用场景：
     * 1.对象的行为依赖于它的状态，并且它必须在运行时根据状态改变它的行为
     * 2.需要编写大量条件分支语句来决定一个操作的行为，而且这些条件恰好表示对象的一种状态
     **/

    /**
     * 策略模式：(policy)
     * 定义了一个共同的抽象算法接口，其子类实现这个接口定义的方法，并且都有各自不同的实现，这些算法实现可以再客户端调用它们的时候互不影响变化
     * 对算法的包装，将使用算法的责任和算法本身分割开，委派给不同的对象管理
     *
     * 适用场景：
     * 上下文和具体策略是弱耦合关系，当增加新的具体策略时，不需要修改上下文类的代码，上下文就可以引用新的具体策略的实例
     **/

    /**
     * 模板方法模式:（templateMethod）
     * 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，即可重定义该算法的某些特定步骤
     *
     * 适用场景：
     * 1.编制一个通用算法，将某些步骤的具体实现留给子类来实现
     * 2.需要重构代码，将各个子类的公共行为提取到一个共同的父类中，避免代码重复
     **/

    /**
     * 解释器模式:（expression）
     * 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子
     *
     * 适用场景：当有一个简单的语言需要解释执行，该语言元素符合文法规则和抽象语法树（运算模型）
     **/

    /**
     * 享元模式:（flyweight）
     * 运用共享技术有效地支持大量细粒度的对象,(数据库/session)
     *
     * 适用场景：
     * 1.对大量对象而言，许多属性是相同的，一旦创建则不能修改
     * 2.对象的多数状态都可变为外部状态
     **/

    /**
     * 适配器模式:（adapter）
     * 将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
     *
     * 适用场景：一个程序想使用已存在的类，但该类实现的接口与当前程序所使用的接口不一致
     **/

    /**
     * 组合模式:（composite）
     * 将对象组合成树形结构以表示"部分-整体"的层次结构，让用户的单个对象和组合对象的使用具有一致性
     *
     * 适用场景：
     * 1.希望表示对象的"部分-整体"层次结构 (如树状结构)
     * 2.希望用户用一致的方式处理个体和组合对象
     *
     **/

    /**
     * 代理模式:（proxy）
     * 为其他对象提供一组代理以控制对这个对象的访问
     * 给某一个对象提供一个代理，并由代理对象控制对原对象的引用
     *
     * 适用场景:
     * 1.不希望用户直接访问该对象，而是提供一个特殊的对象以控制对当前对象的访问
     * 2.如果一个对象需要很长时间才能加载完成
     * 3.如果对象位于远程主机上，需要为用户提供远程访问能力
     *
     **/

    /**
     * 桥接模式(bridge)
     * 将抽象部分与它的实现部分分离，使他们都可以独立的变化
     *
     * 适用场景：
     * 1.不希望抽象和某些重要的实现代码是绑定关系，可运行时动态变化
     * 2.抽象和实现者都可用集成的方式独立的扩充
     * 3.希望实现者层次代码的修改对抽象层不产生影响
     *
     **/

    /**
     * 装饰器模式(decorator)
     * 动态地给对象添加一些额外的职责
     *
     * 适用场景：
     * 程序希望动态的增强类的某个对象的功能，又不影响该类的其他对象
     *
     **/

    /**
     * 外观模式(facade)
     * 为系统中的一组接口提供一个一致的界面，通过定义一个高层接口，是得这一子系统更加容易使用
     *
     * 适用场景：
     * 1.对于一个复杂的子系统，提供一个简单的交互操作
     * 2.不希望客户代码和子类中的类耦合
     *
     **/

}
